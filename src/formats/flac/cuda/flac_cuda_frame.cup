/*
 * This file is part of GPUraku.
 * 
 * GPUraku is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * GPUraku is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with GPUraku.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef FLAC_CUDA_FRAME
#define FLAC_CUDA_FRAME

/*
 * This file contains the function that related to the FLAC frames.
 * Depends: 
 *   - flac_cuda_utf8.cup
 *   - flac_cuda_crc.cup
 */

__global__ void flac_cuda_find_frames(
    uchar * __restrict__ data,
    size_t dataSize, 
    size_t *frameSizes,
    CudaFrameDecode *decodeData,
    size_t lastPos,
    size_t blockSize,
    gruint32 threadCount,
    gruint32 frameCount,
    gruint32 streamSampleRate,
    gruint8 streamChannels,
    gruint8 streamBps)
{
    __shared__ uchar headerCache[CudaThreadBlockSize<<4];
    //Calculate the core index.
    int threadId=blockDim.x * blockIdx.x + threadIdx.x;
    //Calculate the search area.
    size_t startLength=blockSize*threadId;
    //Check area border.
    if(startLength>lastPos)
    {
        //No need to search
        return;
    }
    uchar *startPos=data+startLength, *endPos,
          *cache=headerCache+(threadIdx.x<<4);
    if(threadId<threadCount-1)
    {
        endPos=startPos+blockSize;
    }
    else
    {
        endPos=data+lastPos+2;
    }
    //Loop for the entire data parts.
    while(startPos < endPos)
    {
        //Check for the sync code.
        if(startPos[0]==0xFF && (startPos[1] & 0xFE)==0xF8 &&
            (startPos[3] & 0x01)==0x00)
        {
            CudaFrameDecode frameData;
            //Read the data to shared memory cache.
            cache[1]=startPos[1];
            cache[2]=startPos[2];
            cache[3]=startPos[3];
            //Pass the initial check, parse the header data.
            gruint32 sampleRate=cudaSampleRate[cache[2] & 0x0F];
            frameData.blockSize=cudaBlockSize[(cache[2] & 0xF0)>>4];
            frameData.channel=cudaChannel[(cache[3] & 0xF0)>>4];
            frameData.bitsPerSample=cudaBps[(cache[3] & 0x0E)>>1];
            if(frameData.blockSize && sampleRate && frameData.channel==streamChannels
                && (frameData.bitsPerSample==0 || frameData.bitsPerSample==streamBps))
            {
                //No invalid value found, calculate the CRC-8 to check whether it is frame or not.
                //Read UTF-8 length.
                gruint8 utfByte=(cache[4]=startPos[4]);
                gruint32 headerSize= 5 + (utfByte > 0xBF) + (utfByte > 0xDF) + (utfByte > 0xF0) + 
                                         (utfByte > 0xF7) + (utfByte > 0xFB) + (utfByte == 0xFE),
                         frameIndex;
                //Copy the data to the cache.
                if(headerSize==5)
                {
                    //Simply save the utf byte as the frame index.
                    frameIndex=utfByte;
                }
                else
                {
                    //Need to fetch the data.
                    frameIndex=utfByte & ((1<<(11-headerSize))-1);
                    utfByte=5;
                    while(utfByte<headerSize)
                    {
                        frameIndex=(frameIndex<<6)|((cache[utfByte]=startPos[utfByte])&0x3F);
                        ++utfByte;
                    }
                }
                //Check frame index.
                if(frameIndex<frameCount)
                {
                    //Check the block size skip.
                    if(frameData.blockSize==8)
                    {
                        // 8-bit
                        frameData.blockSize=(gruint32)(cache[headerSize]=startPos[headerSize])+1;
                        ++headerSize;
                    }
                    else if(frameData.blockSize==16)
                    {
                        // 16-bit BE
                        cache[headerSize]=startPos[headerSize];
                        cache[headerSize+1]=startPos[headerSize+1];
                        frameData.blockSize=(cache[headerSize]<<8)|cache[headerSize+1];
                        ++frameData.blockSize;
                        headerSize+=2;
                    }
                    //Check for sample rate fetch mark value.
                    if(sampleRate==8001)
                    {
                        //Fetch 8-bit, unit kHz.
                        cache[headerSize]=startPos[headerSize];
                        ++headerSize;
                    }
                    else if(sampleRate==16 || sampleRate==160)
                    {
                        //Fetch 16-bit, unit Hz.
                        cache[headerSize]=startPos[headerSize];
                        cache[headerSize+1]=startPos[headerSize+1];
                        headerSize+=2;
                    }
                    //Check the sample rate.
                    if(sampleRate==streamSampleRate)
                    {
                        //Calculate the CRC-8 for last checking.
                        gruint8 crc8=0xF3, // Result of CRC-8 0xFF.
                                crcPos=1;
                        while(crcPos<headerSize)
                        {
                            crc8=cudaFlacCrc8Table[crc8^cache[crcPos++]];
                        }
                        if(crc8==startPos[headerSize])
                        {
                            //Frame approval.
                            //Calculate the channel assignment.
                            frameData.channelAssignment=cudaChannelAss[(cache[3] & 0xF0)>>4];
                            //Check bits per sample.
                            if(frameData.bitsPerSample==0)
                            {
                                //Save the bps.
                                frameData.bitsPerSample=streamBps;
                            }
                            //Save the block size, which is the sample size.
                            frameSizes[frameIndex]=frameData.blockSize;
                            //Skip the data.
                            startPos+=(headerSize+1);
                            //Create the bitstream for decoding.
                            frameData.bitStream.data=startPos;
                            frameData.bitStream.cache=(*startPos);
                            frameData.bitStream.bitpos=0;
                            //Write the frame data to the global memory.
                            decodeData[frameIndex]=frameData;
                            //Skip CRC-16 at end, sub frame start at the middle.
                            //Continue to next checking.
                            startPos+=3;
                            continue;
                        }
                    }
                }
                startPos+=3;
            }
        }
        //Move to next byte.
        ++startPos;
    }
}

#endif // FLAC_CUDA_FRAME
