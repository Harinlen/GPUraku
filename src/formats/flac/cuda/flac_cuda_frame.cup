/*
 * This file is part of GPUraku.
 * 
 * GPUraku is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 * 
 * GPUraku is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with GPUraku.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef FLAC_CUDA_FRAME
#define FLAC_CUDA_FRAME

/*
 * This file contains the function that related to the FLAC frames.
 * Depends: 
 *   - flac_cuda_utf8.cup
 *   - flac_cuda_crc.cup
 */

__global__ void flac_cuda_find_frames(
    uchar *data, size_t dataSize, 
    size_t *framePos,
    size_t lastPos,
    size_t blockSize,
    gruint32 threadCount,
    gruint32 frameCount,
    gruint32 streamSampleRate,
    gruint8 streamChannels,
    gruint8 streamBps)
{
    __shared__ cudaUtfFunc utfFunc[8];
    __shared__ cudaCrcFunc crcFunc[16];
    if(threadIdx.x==0)
    {
        utfFunc[1]=cudaUtfL0;
        utfFunc[2]=cudaUtfL1;
        utfFunc[3]=cudaUtfL2;
        utfFunc[4]=cudaUtfL3;
        utfFunc[5]=cudaUtfL4;
        utfFunc[6]=cudaUtfL5;
        utfFunc[7]=cudaUtfL6;
        crcFunc[5]=cudaCrcL5; 
        crcFunc[6]=cudaCrcL6; 
        crcFunc[7]=cudaCrcL7;
        crcFunc[8]=cudaCrcL8; 
        crcFunc[9]=cudaCrcL9; 
        crcFunc[10]=cudaCrcL10; 
        crcFunc[11]=cudaCrcL11;
        crcFunc[12]=cudaCrcL12; 
        crcFunc[13]=cudaCrcL13; 
        crcFunc[14]=cudaCrcL14; 
        crcFunc[15]=cudaCrcL15;
    }
    //Sync the threads for allocating the functions.
    __syncthreads();
    //Calculate the core index.
    int threadId=blockDim.x * blockIdx.x + threadIdx.x;
    //Calculate the search area.
    size_t startLength=blockSize*threadId;
    //Check area border.
    if(startLength>lastPos)
    {
        //No need to search
        return;
    }
    uchar *startPos=data+startLength, *endPos;
    if(threadId<threadCount-1)
    {
        endPos=startPos+blockSize;
    }
    else
    {
        endPos=data+lastPos+2;
        framePos[frameCount]=dataSize;
    }
    gruint32 frameIndex, frameSampleRate;
    gruint8 frameBps, frameSampleRateLength;
    size_t utfLength, headerSize;
    while(startPos < endPos)
    {
        //Check for the sync code.
        if(startPos[0]==0xFF && (startPos[1] & 0xFE)==0xF8 &&
            (startPos[3] & 0x01)==0x00 &&
            //Invalid value check.
            (startPos[2] & 0xF0) && (startPos[2] & 0x0F)!=0x0F &&
            cudaChannel[(startPos[3]&0xF0)>>4]==streamChannels)
        {
            frameBps=cudaBps[(startPos[3]&0x0E)>>1];
            if(frameBps==0 || frameBps==streamBps)
            {
                //Read UTF-8 length.
                //No invalid value found, calculate the CRC-8 to check whether it is frame or not.
                utfLength= (startPos[4] < 0xC0) ? 1 :
                          ((startPos[4] < 0xE0) ? 2 :
                          ((startPos[4] < 0xF0) ? 3 :
                          ((startPos[4] < 0xF8) ? 4 : 
                          ((startPos[4] < 0xFC) ? 5 : 
                          ((startPos[4] < 0xFE) ? 6 : 7)))));
                frameIndex=utfFunc[utfLength](startPos+4);
                if(frameIndex<frameCount)
                {
                    //Calculate the sample rate.
                    frameSampleRate=cudaSampleRate[startPos[2] & 0x0F];
                    frameSampleRateLength=(((startPos[2] & 0x0F)==0x0C)?1:(((startPos[2] & 0x0D)>0x0C)?2:0));
                    headerSize=4+utfLength+
                    (((startPos[2] & 0xF0)==0x60)?1:(((startPos[2] & 0xF0)==0x70)?2:0));
                    //Calculate CRC-8 check.
                    if(frameSampleRateLength==1)
                    {
                        frameSampleRate=startPos[headerSize];
                    }
                    else if(frameSampleRateLength==2)
                    {
                        frameSampleRate=(startPos[headerSize]<<8 | startPos[headerSize+1]);
                    }
                    //Compare the sample rate and CRC-8 result.
                    if(frameSampleRate==streamSampleRate && 
                        crcFunc[headerSize](cudaFlacCrc8Table, startPos)==startPos[headerSize])
                    {
                        //Pass the CRC-8 test, we found a frame.
                        framePos[frameIndex]=startPos-data;
                        //Skip the bytes.
                        startPos+=headerSize+1;
                    }
                    else
                    {
                        startPos+=headerSize-1;
                    }
                }
                else
                {
                    startPos+=3;
                }
            }
        }
        //Move to next byte.
        ++startPos;
    }
}

__global__ void flac_cuda_decode_frames(
    uchar *data, size_t *framePos,
    gruint8 streamBitsPerSample,
    size_t *frameSizes,
    gruint32 frameCount,
    CudaFrameDecode* decodeData)
{
    //Calculate the core index.
    int threadId=blockDim.x * blockIdx.x + threadIdx.x;
    if(threadId >= frameCount)
    {
        return;
    }
    CudaFrameDecode frameData;
    //This index is the frame id we want, decode the frame header.
    data+=framePos[threadId];
    gruint32 sampleRate=cudaSampleRate[data[2] & 0x0F];
    frameData.blockSize=cudaBlockSize[(data[2] & 0xF0)>>4];
    frameData.channel=cudaChannel[(data[3] & 0xF0)>>4];
    frameData.channelAssignment=cudaChannelAss[(data[3] & 0xF0)>>4],
    frameData.bitsPerSample=cudaBps[(data[3] & 0x0E)>>1];
    //Calculate the utf-8 length.
    gruint8 utfLength=((data[4]==0xFE) ? 7 :
                     (((data[4] & 0xFE)==0xFC) ? 6 :
                     (((data[4] & 0xFC)==0xF8) ? 5 :
                     (((data[4] & 0xF8)==0xF0) ? 4 :
                     (((data[4] & 0xF0)==0xE0) ? 3 :
                     (((data[4] & 0xE0)==0xC0) ? 2 : 1))))));
    //Check for the block size fetch value.
    data+=(4+utfLength);
    if(frameData.blockSize==8)
    {
        // 8-bit
        frameData.blockSize=(gruint32)data[0]+1;
        ++data;
    }
    else if(frameData.blockSize==16)
    {
        // 16-bit BE
        frameData.blockSize=TO_UINT16BE(data);
        ++frameData.blockSize;
    }
    //Save the block size, which is the sample size.
    frameSizes[threadId]=frameData.blockSize;
    //Check for sample rate fetch mark value.
    if(sampleRate==8001)
    {
        //Fetch 8-bit, unit kHz.
        ++data;
    }
    else if(sampleRate==16 || sampleRate==160)
    {
        //Fetch 16-bit, unit Hz.
        data+=2;
    }
    //Check bits per sample.
    if(frameData.bitsPerSample==0)
    {
        frameData.bitsPerSample=streamBitsPerSample;
    }
    //Skip CRC-8.
    ++data;
    //Create the bitstream for decoding.
    frameData.bitStream.data=data;
    frameData.bitStream.cache=(*data);
    frameData.bitStream.bitpos=0;
    //Write the frame data to the global memory.
    decodeData[threadId]=frameData;
}

#endif // FLAC_CUDA_FRAME
